rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a strict security model based on user ownership and role-based access control (RBAC). 
     * Student-specific data is private and only accessible by the owning student, while shared application data is publicly readable by 
     * all authenticated users but writable only by administrators.
     *
     * Data Structure: User data (profiles, challenges, hydration records) is nested under a user-specific path, `/users/{userId}`, 
     * which simplifies ownership-based rules. Global data like hydro stations and challenges resides in top-level collections. 
     * Administrator privileges are managed through a dedicated `/roles_admin` collection, where the existence of a document 
     * for a given user ID grants them admin rights.
     *
     * Key Security Decisions:
     * - User Data Privacy: All collections under `/users/{userId}` are strictly controlled, ensuring a user can only ever access their own data.
     * - Admin Privilege Control: The `/roles_admin` collection is read-only for other admins and completely locked down from client-side writes. 
     *   This prevents any user from escalating their own privileges; admin roles must be granted server-side or via the Firebase console.
     * - Read-Only Public Data: `hydro_stations` and `hydration_challenges` are readable by any authenticated user but are immutable for non-admins, 
     *   protecting the integrity of core application data.
     * - Default Deny: Any path or operation not explicitly granted is denied by default.
     *
     * Denormalization for Authorization: The primary authorization strategy is path-based ownership. By nesting all user data under `/users/{userId}`, 
     * we avoid costly `get()` calls to check ownership. For role-based access, we use a `roles_admin` collection, which requires a single, efficient 
     * `exists()` check to verify admin status.
     *
     * Structural Segregation: Private user data (e.g., `hydration_records`) is kept in user-owned subcollections, completely separate from public 
     * collections (`hydro_stations`). This segregation is fundamental to securing list operations and preventing accidental data leakage.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership model.
     * @param userId The user ID to check against the authenticated user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document already exists in Firestore.
     * Critical for safe update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A convenience function that combines an ownership check with an existence check.
     * Used for update and delete operations on user-owned documents.
     * @param userId The user ID to check against the authenticated user's UID.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Checks if the currently authenticated user has admin privileges.
     * Admin status is granted by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Validates that the user ID in a newly created profile document matches the user ID in the path.
     * Enforces relational integrity on creation.
     */
    function isCreatingValidProfile(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates that the user ID field in a profile document is immutable.
     * Prevents re-assigning ownership of a profile on update.
     */
    function isUpdatingImmutableProfile() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that the userProfileId in a new student challenge matches the user ID in the path.
     */
    function isCreatingValidStudentChallenge(userId) {
      return request.resource.data.userProfileId == userId;
    }

    /**
     * Validates that the userProfileId in a student challenge is immutable.
     */
    function isUpdatingImmutableStudentChallenge() {
      return request.resource.data.userProfileId == resource.data.userProfileId;
    }

    /**
     * Validates that the userProfileId in a new hydration record matches the user ID in the path.
     */
    function isCreatingValidHydrationRecord(userId) {
      return request.resource.data.userProfileId == userId;
    }

    /**
     * Validates that the userProfileId in a hydration record is immutable.
     */
    function isUpdatingImmutableHydrationRecord() {
      return request.resource.data.userProfileId == resource.data.userProfileId;
    }

    // --------------------------------------------------------------------------
    // User Data Collections
    // --------------------------------------------------------------------------
    match /users/{userId} {

      /**
       * @description Controls access to a user's profile document(s).
       * @path /users/{userId}/profile/{profileId}
       * @allow (create) An authenticated user creating their own profile document.
       * @deny (get) An authenticated user trying to read another user's profile.
       * @principle Restricts access to a user's own data tree and enforces relational integrity.
       */
      match /profile/{profileId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isCreatingValidProfile(userId);
        allow update: if isExistingOwner(userId) && isUpdatingImmutableProfile();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Controls access to a user's challenge participation records.
       * @path /users/{userId}/student_challenges/{studentChallengeId}
       * @allow (update) An authenticated user updating their own challenge status.
       * @deny (create) An authenticated user trying to create a challenge record for someone else.
       * @principle Restricts access to a user's own data tree and enforces relational integrity.
       */
      match /student_challenges/{studentChallengeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isCreatingValidStudentChallenge(userId);
        allow update: if isExistingOwner(userId) && isUpdatingImmutableStudentChallenge();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Controls access to a user's personal hydration records.
       * @path /users/{userId}/hydration_records/{hydrationRecordId}
       * @allow (list) An authenticated user listing their own hydration history.
       * @deny (delete) An authenticated user trying to delete another user's hydration record.
       * @principle Restricts access to a user's own data tree and enforces relational integrity.
       */
      match /hydration_records/{hydrationRecordId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isCreatingValidHydrationRecord(userId);
        allow update: if isExistingOwner(userId) && isUpdatingImmutableHydrationRecord();
        allow delete: if isExistingOwner(userId);
      }
    }

    // --------------------------------------------------------------------------
    // Global Read-Only Collections (Admin Writable)
    // --------------------------------------------------------------------------

    /**
     * @description Controls access to hydro station information. Authenticated users can read, but only admins can manage the data.
     * @path /hydro_stations/{hydroStationId}
     * @allow (get) Any signed-in user reading a station's location.
     * @deny (create) A regular signed-in user trying to add a new station.
     * @principle Segregates public-read data from private data and uses role-based access for writes.
     */
    match /hydro_stations/{hydroStationId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();

      /**
       * @description Controls access to station error logs. Only admins can view or manage logs.
       * @path /hydro_stations/{hydroStationId}/error_logs/{errorLogId}
       * @allow (create) An admin creating a new error log entry.
       * @deny (get) A regular signed-in user trying to read error logs.
       * @principle Enforces strict admin-only access for sensitive or operational data.
       */
      match /error_logs/{errorLogId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin();
        allow update: if isAdmin() && isExistingDoc();
        allow delete: if isAdmin() && isExistingDoc();
      }
    }

    /**
     * @description Controls access to hydration challenge definitions. Authenticated users can read, but only admins can create or modify them.
     * @path /hydration_challenges/{hydrationChallengeId}
     * @allow (list) Any signed-in user listing available challenges.
     * @deny (update) A regular signed-in user trying to change the points for a challenge.
     * @principle Segregates public-read data from private data and uses role-based access for writes.
     */
    match /hydration_challenges/{hydrationChallengeId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    // --------------------------------------------------------------------------
    // Administrative Collections
    // --------------------------------------------------------------------------

    /**
     * @description Controls access to the admin role collection. Existence of a document here grants a user admin rights.
     * @path /roles_admin/{userId}
     * @allow (get) An admin checking if another user is also an admin.
     * @deny (create) Any user (including an admin) trying to make someone else an admin from the client.
     * @principle Prevents client-side privilege escalation. Admin roles must be managed via server-side logic or the Firebase Console.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}